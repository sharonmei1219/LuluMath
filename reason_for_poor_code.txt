写烂代码的理由

烂代码是一碗蠕虫，迟早会bug纷飞

Kent Beck把烂代码比喻成一碗蠕虫。
这个比喻很精妙，一碗蠕虫只是目前看还没有bug，但终将bug纷飞。

关于写整洁代码，类似的理由我大概可以举出一百多条。然后，现实很冰冷，代码总是几乎无可耐何地快速腐化。
是什么，让一个个专业成熟的团队几乎无一例外地在现实面前选择了不整理代码？
在我们抱怨软件团队不专业，不投入之前，抱怨项目经理短视之前，我们来分析一下软件团队面临的选择问题。

从博弈论的观点来看，人们做出选择是为了让自己的“利益”最大化，“利益”并不狭隘，
如果有人热心公益，一个更有利于公益的策略，就更符合这个人的“利益”，选择这个有利于公益的策略就让他的收益更优。

对于一个专业、成熟的软件团队，在写代码的时候知道：
不去整理代码，可能让项目更快的交付，（在warm没有变成bug之前）。时间就是价值。
同时整理代码，项目交付会晚一些，但是软件维护的成本会大大降低。价值不但可以补偿晚将会的时间成本，而且代码赏心悦目。

团队把写烂代码的收益看做6，把整理代码的收益看做8。因为8大于6，所以团队会选择整理代码。

囚徒困境与公地危机

但往往我们是和很多其它团队工作在同一个代码库上。工作会相互影响。

如果我们整理代码，对方也整理，我们一起得到漂漂亮亮的代码库，收益是8。
如果我们整理代码，对方不整理，我们交付会慢，软件维护仍然很烦，我们的收益降低，变成5。
如果我们不整理代码，对方整理，我们交付会快，和对方一起分担维护，我们的收益增高，变成9。
如果我们不整理代码，对方也不整理，大家的收益都是烂烂的6。

在这样的情况下，我们如何选择呢？

如果对方选择整理，我们选不整理收益是9，选择整理收益是8，因为9大于8，我们会理性地选择不整理。
如果对方选择不整理，我们选不整理收益是6，选择整理收益是5，因为6大于5，我们会理性地选择不整理。

结论是，无论对方如何选择，我们符合理性的选择都是不去整理代码。
更让人难过的是，对方最符合理性的选择也是不去整理代码。

把双方的收益放在一起看：
都不整理代码收益是6+6=12
有一方整理代码收益是9+5=14
双方都整理代码收益是8+8=16

双方的选择，都不整理代码，得到了最差的结果。
这太让人沮丧了，大家各自理智地选择了收益最大化，在一起反而得到了一个最小收益。

这就是鼎鼎大名的“囚徒困境”了。这个结果叫做“效率不充分”

问题是，为什么会出现这种情况？

一个合理的解释是“外部性”。
一方承担的成本给对方带来收益。比如“公地危机”。

“公地危机”是说有一块草地，大家都可以在上放牧，一定会导致草地变秃地。
因为大家都更多地在这块草地上放牧，而更少地对草地进行维护。

我们怎么办？

那么，我们应该怎么办？
通常看到的一些方法有：
一、沟通
二、强制
三、ownership

而据我观察，以上方法都难有效。

小鸡的故事和互相抱怨。

全世界的小鸡在一起讨论如何提高鸡蛋的地位，结论是我们都不下蛋，让人类知道没有我们鸡在下蛋，他们就没有鸡蛋吃。

这一招果然有效，大家开始关注小鸡不生蛋的问题，开始重视小鸡的权益问题。

可是，有一天，一只小鸡只是偶然，不小心生了一只鸡蛋。这下可不得了，人类所有的关注转到了这只小鸡身上，这宝贵的鸡蛋也卖出了天价。

于是，一只又一只的小鸡开始不小心生下了一只只鸡蛋...

不生蛋当然符合全体小鸡的利益，但是，和写整洁代码一样，它是一个不稳定状态，这是说，即便千难万危之后，最终大家达成了一致，并且也一致遵守了协定。
在万一之中，有一个“变种”，它可以在大家都遵守协定的时候，通过不遵守协定获得竞争优势，然后，一个又一个不遵守协定而获利的“变种”就开始变多，协定就失效了。

反而，大家都不写整洁代码是一个稳定状态。所有人都写烂代码的时候，如果出现一个整理代码的“变种”，它的收益也会很糟糕，处于竞争劣势。

我们太多的时候发现沟通无果，会抱怨组织不给力，大家不合作。如果，我们意识到其实是我们大家一起陷入了困境，也许，我们会少一些抱怨，更多的尝试寻找其它方法。


强制，写在文档里的条款。

强制，确实可以让我们摆脱困境，它可以降低写烂代码的收益，让写烂代码变得不那么轻松，通过code review，阻止烂代码交付，迫使烂代码重构等等。

我们考虑问题，不能总想着收益，也应该看到成本。强制会带来管理成本，在我们的经验中，一个看似很好的规定，往往只停在了文档中，原因可能在于实施这个规定投入的成本太高。

如果我们用component owner来管理代码质量，一天在这个模块上有两三个提交，他可能就要花费很多的精力，无暇顾及他本来的开发任务。而我们可能还要让line manager确保component owner确实履行了他的职责。

这还是显性的人力成本。

代码排队等待review会造成交付延迟，时间成本的投入。还会造成代码冲突积累，等等...

自动化的强制，会大大减少这样的成本，比如，在continues integration加入更多的静态、动态代码检查工具都是非常受欢迎的软件开发实践。



Ownership和画地为牢。

在刚才的讨论中，各自追求利益最大化，反而得到整体利益最小的结果，原因在于“外部”性，就是我们常听到的interaction。

自然而然的，每个团队都希望自己的开发不受打扰。
团队会更希望在独立分枝上开发，或者有独立的ownership。

我们之前有文章讨论过独立分枝开发的问题。
独立的ownership有什么问题呢？至少我从软件团队观察，软件团队是没什么问题。问题在于产品团队，开发一个产品，要各个模块配合，当各个团队之间壁垒森严时，就像一个个堰塞湖，产品开发的流处处受阻，时时有overflow的危险。



开发效率与整洁代码并重，训练有素的程序员。

讨论到现在，我们似乎都很难摆脱大家一起写烂代码的困境。
自动化的强制，continues integratoin，可以奏效，是因为提高了写烂代码的代价，降低了写烂代码的收益。

我们稍微改换一下关注点，如果我们进一步降低整理代码的代价，减少因为写整洁代码带来的延时，也就提高了整理代码的收益，也同样可以让我们摆脱一起写烂代码的困境。

怎么作？训练。

斯巴达300勇士，在波希战争中以一当百，靠得就是训练有素。
《异类》的20000小时原则，和最近很热的刻意训练，都在向我们揭示，想要有出色的成绩，一定要经过艰苦的训练。
我的孩子在学习舞蹈，一周三个小时，一年一百多小时下来，可能都没有一次登台机会。
而我们的工程师怎么写代码是几乎没有平时的训练，一上手就是产品代码。又很少能见到有工程师把当程序员当作自己的终生职业规划。

总结，还有我的观点。

我们在一起写烂代码是因为我们一起陷入了囚徒困境。
沟通然后抱怨，一轮轮地讨论ownership，代码流程，可能在解决代码内部质量总是上收效甚微。
我不反对继续讨论，但可以做得更好，知道之前做过什么样的讨论，哪些讨论结果有效，哪些无效，然后，努力避免无效讨论周而复始，release over release, year after year的讨论。

有效的方法有我最受的Kent Beck极限编程中Continues Integration这个软件实践。
我个人认为，我们在程序员的素养培养能有更多的提高。