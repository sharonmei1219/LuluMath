写烂代码的理由
囚徒困境，工作中的博弈（一）

烂代码是一碗蠕虫，迟早会bug纷飞。

 

Kent Beck有个精妙的比喻，他说烂代码是一碗蠕虫。
碗里没有bug，但终将bug纷飞。

关于整洁代码，怎么强调都不过分。然而，现实很冰冷，太多的代码总是无可耐何地快速腐化。
是什么，让一个个团队在现实面前选择了写烂代码？

问题并不像表面看上去那么简单，不是我们经常抱怨的那样，开发团队不努力，管理团队太短视。
如何写代码是一个策略选择问题，是博弈问题。陷入博弈问题中，哪怕是专业、成熟的团队，也会选择写烂代码。

在博弈中，策略选择的目的是“收益”最大化。

写烂代码，快速而潦草地写各种硬编码，写扭曲但足以应付的逻辑，可以让项目更快的交付。更快的交付就是价值，时间的价值。
写整洁的代码，静下心来写严谨的逻辑，合适的模式，准确的命名，会多用一些时间，带来的是更容易维护的软件，更容易扩展的软件，节省了测试成本，维护成本和再开发成本。

在一个专业、成熟的软件团队眼中，整洁代码带来的长久收益足以弥补时间上的损失，收益大于写烂代码的收益。
如果把写整洁代码的收益记作8，写烂代码的收益记作6。
因为8>6，所以选择写整洁的代码。

一个团队单独作理性决策，会选择写整洁的代码。



囚徒困境与公地悲剧


在现实工作中，往往是多个团队共同工作在同一个代码库上，工作会相互影响。

如果大家都写整洁的代码，每个团队的收益都是8。
如果大家都写烂代码，每个团队的收益都是6。
如果大家都写整洁代码，有个团队选择写烂代码，显然这个团队可以快速交付，软件维护成本大家分摊。写烂代码的收益会变大，记作9。
如果大家都写烂代码，有下团队坚持写整洁的代码，交付会变得更困难，代码也不会明显改观，还要负担更多的维护任务，收益会大大降低，记作5

在这样的情况下，我会如何选择呢？

如果大家都选择写整洁代码，
1.	我选择写烂代码收益是9，
2.	选择写整洁代码收益是8，
因为9大于8，我会理性地选择写烂代码。

如果大家都选择写烂代码，
1.	我选择写烂代码的收益是6，
2.	选择写整洁代码的收益是5，
因为6大于5，我同样会理性地选择写烂代码。

无论大家怎么选，我符合自身利益的选择都是写烂代码。尽管作为专业程序员，我认为写整洁代码的收益大于写烂代码的收益。

让人难过的是，每个团队符合自身利益的理性选择会和我一样的，写烂代码。

这太让人沮丧了，大家各自理智地选择了收益最大化，写烂代码，带来的整体收益是6n，并没有能让整体得到更好的结果，写整洁代码，整体收益是8n。

这是因为团队陷入了一种博弈困境，“囚徒困境”。在囚徒困境中，两个囚徒会出于自身利益背叛对方，理由和我们选择写烂代码的理由是一样的

所有的团队在一起没能得到一个本可以更好的结果，明显“效率不充分”。
对于这样的“效率不充分”，有一个合理的解释是“外部性”。
“外部性”一方承担的成本给对方带来收益，或者一方获得收益却不用承担成本。

比如在公共草地上，有一群牧羊人，每一个牧羊人都想要多获利一些，所以某个牧羊人就带了大量的羊来放牧，虽然他知道过度放牧，草地可能会承受不住。但他依然获利了，而后所有的牧羊人都跟进，所以草地牧草耗竭，悲剧因而发生了。

这样悲剧就是“公地悲剧”。

讨论到这里，可以看出，团队选择写烂代码，不像表面上看来那么简单，不是因为软件团队不努力，不是因为项目团队太短视。
团队选择写烂代码可有可能是陷入了“囚徒困境”，导致了“效率不充分”，其原因在于“外部性”。



我们怎么办？

那么，我们应该怎么办？
通常看到的一些方法有：
一、沟通
二、流程
三、代码所有权

这样的方法几乎是年复一年地在讨论，它们真的有效吗？
 


沟通，小鸡的故事和互相抱怨。



有一天，全世界的小鸡在一起讨论如何提高鸡蛋的地位，得出的结论是如果小鸡都不下蛋，人类就会知道鸡蛋宝贵。
这一招果然有效，所有的小鸡都不下蛋了，鸡蛋变得非常宝贵，人类也开始关注小鸡不生蛋的问题，开始重视小鸡的权益问题。

可是，在某一天，一只小鸡只是偶然，不小心生了一只鸡蛋。这下可不得了，人类所有的关注转到了这只小鸡身上，这宝贵的鸡蛋也卖出了天价。

然后，一只又一只的小鸡开始不小心生下了一只只鸡蛋...

不生蛋当然符合全体小鸡的利益，但是，和写整洁代码一样，它是一个“不稳定状态”，这是说，即便千难万危之后，最终大家达成了一致，并且也一致遵守了协定。
在万一之中，有一个“变种”，它可以在大家都遵守协定的时候，通过不遵守协定获得竞争优势，然后，一个又一个不遵守协定而获利的“变种”就开始变多，协定就失效了。

与此类似，大家都写整洁代码是一个“不稳定状态”，相反，大家都写烂代码却是一个“稳定状态”。当所有人都写烂代码的时候，如果出现一个整理代码的“变种”，它的收益也会很糟糕，处于竞争劣势。几乎可见的是，因为延迟了交付，代码也没有明显的改善，这个团队会面临种种质疑，然后要么改变策略，要么解散。

寄希望于通过沟通让使大家都选择一个不稳定的博弈状态是徒劳无功。

沟通没有效果，但如果能意识到团队其实是陷入了困境，也许会减少一些抱怨，甚至减少一些不必要的会议。




流程，写在文档里的条款



流程，带有强制性的流程，可以让我们摆脱困境。

它可以降低写烂代码的收益，代价是更多的管理成本。

强制性的条款让写烂代码变得不那么轻松，审查代码，阻止烂代码交付，迫使烂代码重构等等，降低了写烂代码的收益的，收益的改变会改变团队的策略选择，从而摆脱“囚徒困境”。

另一方面，强制性流程会带来管理成本，一些看似好的流程，只停在了文档中，原因可能在于执行这个流程投入的成本太高。

显性的成本包括投入更多的人力来审查代码，如果一个软件模块上一天有两三次代码交付，那么可能需求额外地投入一个人专职做代码评审。
同时，代码排队等待评审，也会带来更高的时间成本。

自动化的流程，会大大减少这样的成本，比如，在持续集成环境中加入更多的代码检查工具，会让减少人工代码审查的工作量，同时让工特别是得到反馈的时间也会大大缩短，是非常受欢迎的软件开发实践。



代码所有权，和堰塞湖


理性的开发团队，独自开发的时候，会选择写整洁的代码，多个团队共同开发的时候，却会选择写烂代码。
根本原因是来自开发过程中的“外部性”。

写整洁代码的带来收益，并不只惠及写整洁代码的团队，而是大家共同分享。
写烂代码带来的损失，并不只是拖累写烂代码的团队，而是大家共同分担。

自然而然的，每个团队都希望自己的开发不受打扰。
团队会更希望在独立分枝上开发，或者有独立的所有权(code ownership)，一个模块上只有一个团队可以作开发工作。

之前我在“合成谬误”的文章中讨论过独立分枝开发的问题。
独立的代码所有权（code ownership）有什么问题呢？

问题不在软件团队，而在产品团队，
开发一个产品，要各个模块配合，当各个团队之间壁垒森严时，就像一个个堰塞湖，堰塞湖最好的状态就是不饱和状态，也就是效率不充分状态。只要有一个过载(overflow)，会整个产品受灾。

产品开发的流处处受阻，时时有overflow的危险。


沟通，流程和代码所有权是对待烂代码时最常见的处理手段，有有效的，有无效的。
这些方法无一


训练有素，斯巴达300勇士



我们稍微改换一下关注点，如果我们进一步降低整理代码的代价，减少因为写整洁代码带来的延时，也就提高了整理代码的收益，也同样可以让我们摆脱一起写烂代码的困境。

怎么作？训练。

斯巴达300勇士，在波希战争中以一当百，靠得就是训练有素。
《异类》的20000小时原则，和最近很热的刻意训练，都在向我们揭示，想要有出色的成绩，一定要经过艰苦的训练。
我的孩子在学习舞蹈，一周三个小时，一年一百多小时下来，可能都没有一次登台机会。
而我们的工程师怎么写代码是几乎没有平时的训练，一上手就是产品代码。又很少能见到有工程师把当程序员当作自己的终生职业规划。

总结，还有我的观点。

我们在一起写烂代码是因为我们一起陷入了囚徒困境。
沟通然后抱怨，一轮轮地讨论ownership，代码流程，可能在解决代码内部质量总是上收效甚微。
我不反对继续讨论，但可以做得更好，知道之前做过什么样的讨论，哪些讨论结果有效，哪些无效，然后，努力避免无效讨论周而复始，release over release, year after year的讨论。

有效的方法有我最受的Kent Beck极限编程中Continues Integration这个软件实践。
我个人认为，我们在程序员的素养培养能有更多的提高。
