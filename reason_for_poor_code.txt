写烂代码的理由
囚徒困境，工作中的博弈（一）

烂代码是一碗蠕虫，迟早会bug纷飞。

 

Kent Beck有个精妙的比喻，他把烂代码比喻成一碗蠕虫。
碗里目前还没有bug，但终将bug纷飞。

关于写整洁代码，无论如何强调都不过分。然后，现实很冰冷，太多的组织中代码总是几乎无可耐何地快速腐化。
是什么，让一个个专业成熟的团队几乎无一例外地在现实面前选择了写烂代码？
在我们抱怨软件团队不专业，不投入之前，抱怨项目经理短视之前，我们来分析一下软件团队面临的选择问题。

人们在做一项决策之前，会掂量一下这个决策会带来怎样的“收益”。决策的目的就使这个“收益”最大化。

一个专业、成熟的软件团队知道：
各种硬编码，扭曲但足以应付的逻辑，让代码看着很烂但可以让项目更快的交付，时间就是价值。
严谨的测试，合适的模式，准确的命名，让代码赏心悦目，项目交付会晚一些，但是软件维护的成本会大大降低，未来开发新项目的成本也会降低。

因此这样的团队会认同整洁代码带来的“收益“会大于烂代码带来的“好处”，为了方便，我们把整洁代码的“收益”记作8，把烂代码的“收益”记作6。

所以，如果是一个专业软件团队单独作出决策，因为收益8>6，出于自身的利益诉求会选择写整洁的代码

 

囚徒困境与公地悲剧

但往往我们是和很多其它团队工作在同一个代码库上。工作会相互影响。

考虑一下大家相互合作时我们的收益：
如果我们整理代码，对方也整理，收益是8。
如果我们整理代码，对方不整理，我们交付会慢，软件维护仍然很烦，我们的收益降低，变成5。
如果我们不整理代码，对方整理，我们交付会快，和对方一起分担维护，我们的收益增高，变成9。
如果我们不整理代码，对方也不整理，大家的收益都是烂烂的6。

在这样的情况下，我们如何选择呢？

如果对方选择整理，
1.	我们选不整理收益是9，
2.	选择整理收益是8，
因为9大于8，我们会理性地选择不整理。

如果对方选择不整理，
1.	我们选不整理收益是6，
2.	选择整理收益是5，
因为6大于5，我们会理性地选择不整理。

让人难过的是，无论对方如何选择，我们符合自身利益的选择都是不去整理代码。
更让人难过的是，对方最符合理性的选择也是不去整理代码。
更让人难过的是，把大家的收益放在一起看：
都不整理代码收益是6+6=12
有一方整理代码收益是9+5=14
双方都整理代码收益是8+8=16

这太让人沮丧了，大家各自理智地选择了收益最大化，都不整理代码，加在一起反而得到了一个最小收益。

这就是我们日常工作中遇到的“囚徒困境”。导致的结果是我们没能得到一个本可以更好的结果，这个叫作“效率不充分”。

一个合理的解释是“外部性”。
“外部性”一方承担的成本给对方带来收益，或者一方获得收益却不用承担成本。比如“公地悲剧”。

公共草地上，有一群牧羊人，每一个牧羊人都想要多获利一些，所以某个牧羊人就带了大量的羊来放牧，虽然他知道过度放牧，草地可能会承受不住。但他依然获利了，而后所有的牧羊人都跟进，所以草地牧草耗竭，悲剧因而发生了。

我们怎么办？

那么，我们应该怎么办？
通常看到的一些方法有：
一、沟通
二、强制
三、ownership


 

沟通，小鸡的故事和互相抱怨。

全世界的小鸡在一起讨论如何提高鸡蛋的地位，结论是我们都不下蛋，让人类知道没有我们鸡在下蛋，他们就没有鸡蛋吃。

这一招果然有效，大家开始关注小鸡不生蛋的问题，开始重视小鸡的权益问题。

可是，有一天，一只小鸡只是偶然，不小心生了一只鸡蛋。这下可不得了，人类所有的关注转到了这只小鸡身上，这宝贵的鸡蛋也卖出了天价。

于是，一只又一只的小鸡开始不小心生下了一只只鸡蛋...

不生蛋当然符合全体小鸡的利益，但是，和写整洁代码一样，它是一个不稳定状态，这是说，即便千难万危之后，最终大家达成了一致，并且也一致遵守了协定。
在万一之中，有一个“变种”，它可以在大家都遵守协定的时候，通过不遵守协定获得竞争优势，然后，一个又一个不遵守协定而获利的“变种”就开始变多，协定就失效了。

反而，大家都不写整洁代码是一个稳定状态。所有人都写烂代码的时候，如果出现一个整理代码的“变种”，它的收益也会很糟糕，处于竞争劣势。

我们太多的时候发现沟通无果，会抱怨组织不给力，大家不合作。如果，我们意识到其实是我们大家一起陷入了困境，也许，我们会少一些抱怨，更多的尝试寻找其它方法。

强制，写在文档里的条款

强制，确实可以让我们摆脱困境，它可以降低写烂代码的收益，让写烂代码变得不那么轻松，通过code review，阻止烂代码交付，迫使烂代码重构等等。

我们考虑问题，不能总想着收益，也应该看到成本。强制会带来管理成本，在我们的经验中，一个看似很好的规定，往往只停在了文档中，原因可能在于实施这个规定投入的成本太高。

如果我们用component owner来管理代码质量，一天在这个模块上有两三个提交，他可能就要花费很多的精力，无暇顾及他本来的开发任务。而我们可能还要让line manager确保component owner确实履行了他的职责。

这还是显性的人力成本。

代码排队等待review会造成交付延迟，时间成本的投入。还会造成代码冲突积累，等等...

自动化的强制，会大大减少这样的成本，比如，在continues integration加入更多的静态、动态代码检查工具都是非常受欢迎的软件开发实践。

Ownership，和画地为牢
在刚才的讨论中，各自追求利益最大化，反而得到整体利益最小的结果，原因在于“外部”性，就是我们常听到的interaction。

自然而然的，每个团队都希望自己的开发不受打扰。
团队会更希望在独立分枝上开发，或者有独立的ownership。

我们之前有文章讨论过独立分枝开发的问题。
独立的ownership有什么问题呢？至少我从软件团队观察，软件团队是没什么问题。问题在于产品团队，开发一个产品，要各个模块配合，当各个团队之间壁垒森严时，就像一个个堰塞湖，产品开发的流处处受阻，时时有overflow的危险。

训练有素，斯巴达300勇士

讨论到现在，我们似乎都很难摆脱大家一起写烂代码的困境。
自动化的强制，continues integratoin，可以奏效，是因为提高了写烂代码的代价，降低了写烂代码的收益。

我们稍微改换一下关注点，如果我们进一步降低整理代码的代价，减少因为写整洁代码带来的延时，也就提高了整理代码的收益，也同样可以让我们摆脱一起写烂代码的困境。

怎么作？训练。

斯巴达300勇士，在波希战争中以一当百，靠得就是训练有素。
《异类》的20000小时原则，和最近很热的刻意训练，都在向我们揭示，想要有出色的成绩，一定要经过艰苦的训练。
我的孩子在学习舞蹈，一周三个小时，一年一百多小时下来，可能都没有一次登台机会。
而我们的工程师怎么写代码是几乎没有平时的训练，一上手就是产品代码。又很少能见到有工程师把当程序员当作自己的终生职业规划。

总结，还有我的观点。

我们在一起写烂代码是因为我们一起陷入了囚徒困境。
沟通然后抱怨，一轮轮地讨论ownership，代码流程，可能在解决代码内部质量总是上收效甚微。
我不反对继续讨论，但可以做得更好，知道之前做过什么样的讨论，哪些讨论结果有效，哪些无效，然后，努力避免无效讨论周而复始，release over release, year after year的讨论。

有效的方法有我最受的Kent Beck极限编程中Continues Integration这个软件实践。
我个人认为，我们在程序员的素养培养能有更多的提高。
